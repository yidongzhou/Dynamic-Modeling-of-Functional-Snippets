#' Estimate Covariance Function
#' @param t a list of vectors (for irregular design) or a vector (for regular design) containing time points of observations for each individual; each vector should be in ascending order.
#' @param y a list of vectors (for irregular design) or a matrix (for regular design) containing the observed values at \code{t}; if it is a matrix, the columns correspond to the time points in the vector \code{t}.
#' @param newt  a list of vectors or a vector containing time points of observations to be evaluated; if NULL, then \code{newt} is treated as \code{t}.
#' @param mu the known or estimated mean function object; it must be a scalar (viewed as a constant function), a function handle, or an object obtained by calling \code{meanfunc}
#' @param method estimation method, 'PACE' or 'FOURIER' or 'SP' (for semiparametric method)
#' @param weig a vector of \code{length(t)} of weight for each subject, or 'OBS' or 'SUBJ' for weighting scheme
#' @param tuning tuning method to select possible tuning parameters
#' @param ... other parameters required depending on the \code{method} and \code{tuning}; see details
#' @details
#'     \itemize{
#'         \item{When \code{method='PACE'}, additional parameters are}
#'         \describe{
#'             \item{\code{kernel}}{kernel type; supported are 'epanechnikov', "rectangular", "triangular", "quartic", "triweight", "tricube", "cosine", "gauss", "logistic", "sigmoid" and "silverman"; see https://en.wikipedia.org/wiki/Kernel_(statistics) for more details.}
#'             \item{\code{deg}}{degree of the local polynomial regression; currently only \code{deg=1} is supported.}
#'             \item{\code{bw}}{bandwidth}
#'         }
#'         \item{When \code{method='FOURIER'}, additional parameters are}
#'         \describe{
#'             \item{\code{q}}{number of basis functions; if \code{NULL} then selected by \code{tuning} method}
#'             \item{\code{rho}}{roughness penalty parameter; if \code{NULL} then selected by \code{tuning} method}
#'             \item{\code{ext}}{extension margin of Fourier extension; if \code{NULL} then selected by \code{tuning} method}
#'             \item{\code{domain}}{time domain; if \code{NULL} then estimated by \code{(min(t),max(t))}}
#'         }
#'         \item{When \code{method='SP'}, additional parameters are} 
#'         \describe{
#'             \item{\code{domain}}{time domain; if \code{NULL} then estimated by \code{(min(t),max(t))}}
#'             \item{\code{corf}}{function of the form \code{function(theta,x,y)} that specifies the correlation structure with parameter \code{theta}; If NULL then Matern correlation is used.}
#'             \item{\code{sig2e}}{variance of measurement error; if \code{NULL} the automatically calculated by the calling \code{sigma2}}
#'             \item{\code{sig2x}}{variance function; a function or an object generated by \code{varfunc}; if \code{NULL} then automatically estimated by calling \code{varfunc}}
#'             \item{\code{pfunc}}{penalty function on the estimation; Not used yet.}
#'             \item{\code{theta0}}{Initial value for the parameter \code{theta} to be estimated; \code{NULL} by default}
#'             \item{\code{lb}}{vector of lower bound of \code{theta}; if \code{NULL} then set to \code{-Inf} for all coordinate}
#'             \item{\code{ub}}{vector of upper bound of \code{theta}; if \code{NULL} then set to \code{Inf} for all coordinate}
#'             \item{\code{D}}{dimension of \code{theta}}
#'         }
#'     }
#'
#' @return an object of the class 'covfunc' containing necessary information to predict/evaluate the estimated covariance function and the following output:
#'     \itemize{
#'         \item{When \code{method='PACE'}, additional parameters are}
#'         \describe{
#'             \item{\code{fitted}}{fitted value at the grid spanned by \code{newt}}
#'             \item{\code{delta}}{the largest span among all subjects; note that it is not normalized by the span of the whole study.}
#'             \item{\code{bw}}{selected bandwidth by \code{tuning} method if \code{NULL} is the input for \code{bw}.}
#'             \item{\code{mu}}{estimated mean function if \code{NULL} is the input.}
#'         }
#'         \item{When \code{method='FOURIER'}, additional parameters are}
#'         \describe{
#'             \item{\code{fitted}}{fitted value at the grid spanned by \code{newt}}
#'             \item{\code{q}}{selected \code{q} if \code{NULL} is the input}
#'             \item{\code{rho}}{selected \code{rho} if \code{NULL} is the input}
#'             \item{\code{ext}}{selected \code{ext} if \code{NULL} is the input}
#'             \item{\code{C}}{estimated coefficients}
#'             \item{\code{mu}}{estimated mean function if \code{NULL} is the input.}
#'         }
#'         \item{When \code{method='SP'}, additional parameters are} 
#'         \describe{
#'             \item{\code{fitted}}{fitted value at the grid spanned by \code{newt}}
#'             \item{\code{domain}}{time domain; if \code{NULL} then estimated by \code{(min(t),max(t))}.}
#'             \item{\code{rho}}{estimated function of the form \code{function(x,y)} of the correlation structure.}
#'             \item{\code{sig2e}}{estiamted variance of measurement error if \code{NULL} is the input.}
#'             \item{\code{sig2x}}{estiamted variance function if \code{NULL} is the input.}
#'             \item{\code{theta}}{estimated parameters for the correlation structure.}
#'             \item{\code{mu}}{estimated mean function if \code{NULL} is the input.}
#'         }
#'     }
#' 
#' @importFrom Rdpack reprompt
#' @references 
#' \insertRef{Lin2020b}{mcfda}
#' 
#' \insertRef{Lin2020}{mcfda}
#' 
#' \insertRef{Yao2005}{mcfda}
#' 
#' @examples
#' mu <- function(s) sin(2*pi*s)
#' D <- synfd::sparse.fd(mu=mu, X=synfd::gaussian.process(), n=100, m=5)
#' mu.obj <- meanfunc(D$t,D$y,newt=NULL,method='PACE',
#'                    tuning='cv',weig=NULL,kernel='gauss',deg=1)
#' cov.obj <- covfunc(D$t,D$y,newt=NULL,mu=mu.obj,method='FOURIER',
#'                    tuning='cv',weig=NULL,domain=c(0,1))
#' cov.hat <- predict(cov.obj,regular.grid())
#' @export covfunc
#' @useDynLib mcfda

covfunc <- function(Ly,Lt,bw=NULL,newt=NULL,
                   domain=NULL,
                   corf=NULL, # correlation function(theta,x,y)
                   mu=NULL,
                   weig=NULL,
                   sig2e=NULL,
                   sig2x=NULL,
                   pfunc=NULL,
                   theta0=NULL,
                   lb=NULL,
                   ub=NULL,
                   D=NULL)
{
  if(is.null(corf)){
    corf <- function(x,y,theta) matern(x,y,nu=theta)
    D <- 1
  }
  else
  {
    if(is.null(theta0) && is.null(D)) stop('The dimension D must be specified')
  }
  
  if(is.null(mu))
  {
    mu <- meanfunc(Ly, Lt, domain = domain)
  }
  
  mu.hat <- predictmf(mu,Lt)
  
  if(is.null(sig2e)) {
    sig2e <- sigma2(Ly,Lt,bw,mu.hat)
  }
  
  if(is.null(sig2x))
  {
    sig2x <- varfunc(Ly,Lt,bw=bw,sig2=sig2e,mu=mu)
  }
  var.hat <- predictvf(sig2x,Lt)
  
  if(is.null(domain))
  {
    t.vec <- unlist(Lt)
    domain <- c(min(t.vec),max(t.vec))
  }
  
  th.est <- estimate.theta(Ly,Lt,
                           D=D,
                           var.hat=var.hat,
                           mu.hat=mu.hat,
                           method='LS',
                           rho=corf,
                           weig=weig,
                           pfunc=pfunc,
                           theta.lb=lb,
                           theta.ub=ub,
                           theta0=theta0,
                           domain=domain)$LS
  
  rslt <- list(sig2e=sig2e,
               theta=th.est,
               mu.hat=mu.hat,
               domain=domain,
               mu=mu,
               sig2x=sig2x,
               rho=function(x,y) corf(x,y,th.est))
  class(rslt) <- 'covfunc'
  
  if(!is.null(newt))
    rslt$fitted <- predictcf(rslt,newt)
  
  return(rslt)
}

# matern correlation
matern <- function(x,y=NULL,nu=1,rho=1)
{
  if(is.null(y)) y <- x
  
  G <- expand.grid(x,x)
  
  S <- apply(G,1,function(z){
    delta <- abs(z[1]-z[2])/rho
    if(delta == 0) {
      1
    }
    else {
      nu <- max(nu, 1e-05)
      (sqrt(2*nu)*delta)^nu * besselK(sqrt(2*nu)*delta,nu=nu) / (2^(nu-1)*gamma(nu))
    }
  })
  
  C <- matrix(S,nrow=length(x),ncol=length(y),byrow=F)
  return(C)
}


#' Estimate the parameters of the correlation structure
#' @param weig a vector of length(Lt)
#' @param D the number of parameters
#' @param sig0.hat the estimate of variance of measure error
#' @keywords internal
estimate.theta <- function(Ly,Lt,
                           D,
                           var.hat,
                           mu.hat,
                           method,
                           rho,
                           weig=NULL,
                           theta.lb=NULL,
                           theta.ub=NULL,
                           h=0.1,
                           domain=c(0,1),
                           pfunc=NULL,
                           theta0=NULL)
{
  if(is.null(weig))   weig <- rep(1,length(Lt))
  if(is.null(pfunc)) pfunc <- function(th){return(0)}
  
  sig <- lapply(var.hat,function(x){
    x <- ifelse(x <=0,yes=1e-8,no=x)
    sqrt(x)
  })
  
  n <- length(Lt)
  result <- list()
  
  if('LS' %in% method)
  {
    R <- sapply(1:n,function(i){
      tobs <- Lt[[i]]
      idx <- (tobs >= domain[1]+h) & (tobs <= domain[2]-h)
      yy <- Ly[[i]]
      yy <- yy[idx]
      mu <- mu.hat[[i]]
      mu <- mu[idx]
      resid <- yy-mu
      return(list(cbind(resid) %*% rbind(resid)))
    })
    
    TT <- sapply(1:n,function(i){
      tobs <- Lt[[i]]
      idx <- (tobs >= domain[1]+h) & (tobs <= domain[2]-h)
      tobs[idx]
    })
    
    SS <- sapply(1:n,function(i){
      tobs <- Lt[[i]]
      idx <- (tobs >= domain[1]+h) & (tobs <= domain[2]-h)
      sig.t <- sig[[i]]
      sig.t <- sig.t[idx]
      diag(sig.t)
    })
    
    Q <- function(theta){
      if(any(theta < theta.lb) || any(theta > theta.ub)) return(1e300)
      v <- sapply(1:n,function(i){
        tobs <- TT[[i]]
        if(length(tobs)==1) return(0)
        
        rho.mat <- rho(tobs,tobs,theta)
        if(any(is.infinite(rho.mat)) || any(is.nan(rho.mat)))
        {
          theta
          tobs
        }
        S <- SS[[i]]
        # print(tobs)
        # print(dim(S))
        # print(dim(rho.mat))
        resid <- (S %*% rho.mat %*% S - R[[i]])^2
        diag(resid) <- 0 # remove points on diagonal
        return(sum(resid))
      })
      
      if(!is.finite(sum(v*weig)))    return(1e300)
      return(sum(v*weig) + pfunc(theta)) # regularization
    }
    
    # set up initial value for optimization
    if(is.null(theta.lb)) theta.lb <- rep(-Inf,D)
    if(is.null(theta.ub)) theta.ub <- rep(Inf,D)
    
    if(is.null(theta0))
      v <- sapply(1:D,function(d){
        lb <- theta.lb[d]
        ub <- theta.ub[d]
        if(lb > -Inf && ub < Inf) return(runif(1)*(ub-lb)+lb)
        else if(lb > -Inf) return(runif(1)+lb)
        else if(ub < Inf) return(ub-runif(1))
        else return(runif(1))
      })
    else v <- theta0
    res <- optim(v,Q,lower=theta.lb,upper=theta.ub,method='L-BFGS-B')
    result$LS <- res$par
    result$Q <- Q(res$par)
  }
  
  return(result)
}


#' predict cov functions at new locations
#' @param covobj the object obtained by calling \code{covfunc}
#' @param newt a vector or a list of vectors of real numbers
#' @return the estimated mean function evaluated at \code{newt}. It has the same format of \code{newt}
#' @export
predictcf <- function(covobj,newt)
{
    pred <- function(newt) # newt is a vector
    {
        stopifnot(is.vector(newt))

        corr.est <- covobj$rho(newt,newt)
        var.hat <- predictvf(covobj$sig2x,newt)
        sig.hat <- sqrt(var.hat)
        cov.fitted <- corr.est * (sig.hat %*% t(sig.hat))
        return(cov.fitted)
    }


    if(is.list(newt))
    {
        return(lapply(newt, function(newx) pred(newx)))
    }
    else if(is.vector(newt))
    {
        return(pred(newt))
    }
    else stop('newt must be a vector or a list of vectors of real numbers')
}
