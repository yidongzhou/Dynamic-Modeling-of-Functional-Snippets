#' Estimate the variance function
#' @param Lt a list (for irregular design) or a vector (for regular design) of observations in time domain
#' @param Ly a list (for irregular design) or a matrix (for regular design) of observations corresponding to \code{Lt}
#' @param sig2 variance of noise
#' @param newt a set of locations where the variance function is estimated. If NULL, then set to \code{Lt}
#' @param weig a vector of length(Lt). If NULL, then determined by the algorithm.
#' @param mu an object generated by \code{meanfunc}.
#' @param ... other parameters required depending on the \code{method} and \code{tuning}; see details
#' @details
#'     \itemize{
#'         \item{When \code{method='PACE'}, additional parameters \code{kernel} and \code{deg} can be provided. \code{bw} as a scalar is optional. When \code{bw} is provided, the bandwidth is set to \code{bw}}
#'         \item{When \code{method='FOURIER'}, additional parameters \code{q},\code{rho},\code{ext} and \code{domain} are optional. If they are not provided, then they will be deduced from data or selected by the specified \code{tuning} method.}
#'     }
#' @export
varfunc <- function(Ly,Lt,bw=NULL,newt=NULL,sig2=NULL,mu=NULL)
{
    if(is.list(Lt) && is.list(Ly))
    {
        n <- length(Lt)
        datatype <- 'irregular'
    }
    else if(is.vector(Lt) && is.matrix(Ly))
    {
        n <- nrow(Ly)
        datatype <- 'regular'
    }
    else stop('unsupported data type')

    if(is.null(sig2)) sig2 <- sigma2(Ly,Lt,bw)

    if(datatype == 'irregular')
    {
        vLy <- lapply(1:n,function(i){
            if(is.function(mu)) mui <- mu(Lt[[i]])
            else mui <- predictmf(mu,Lt[[i]])
            yi <- Ly[[i]] - mui
            yi <- yi^2
            yi
        })
    }
    else
    {
        if(is.function(mu)) vmui <- rep.row(mu(Lt),n)
        else mui <- rep.row(predictmf(mu,Lt),n)
        vLy <- (Ly - mui)^2
    }

    R <- list(obj=meanfunc(vLy,Lt,bw=bw),sig2=sig2)
    class(R) <- 'varfunc'

    if(is.null(newt))
    {
        newt <- Lt
    }

    R$fitted <- predictvf(R,newt)

    return(R)
}

#' @export
predictvf <- function(R,newt)
{
    tmp <- predictmf(R$obj,newt)
    if(is.list(tmp))
    {
        lapply(tmp,function(x){
            raw <- x - R$sig2
            raw[raw < 0] <- 0
            return(raw)
        } )
    }
    else if(is.vector(tmp)){
        raw <- (tmp-R$sig2)
        raw[raw < 0] <- 0
        return(raw)
    }
    else stop('unrecognized/unsupported data type')
}

#' replicate a row vector into a matrix
#' @param x the row vector to be replicated
#' @param n replicate the row vector n times
#' @return a matrix of the dimension of \code{n} by \code{length(x)}
#' @export rep.row

rep.row <- function(x,n){
  matrix(rep(x,each=n),nrow=n)
}